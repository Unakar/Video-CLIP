# CLIP4Clip

## Abstruct

在本文中，作者提出了一个 CLIP4Clip 模型，以端到端的方式将 CLIP 模型的知识转移到视频语言检索中。在本文中，作者通过实验研究了以下几个问题：

1） 图像特征是否足以用于视频文本检索？

2） 基于 CLIP 的大规模视频文本数据集的后预训练如何影响性能？

3） 对视频帧之间的时间依赖性建模的实用机制是什么？

4） 该模型对视频文本检索任务的超参数敏感性。

大量实验结果表明，基于 CLIP 的 CLIP4Clip 模型可以在各种视频文本检索数据集上实现 SOTA 结果，包括 MSR-VTT、MSVC、LSMDC、ActivityNet 和 DiDeMo。

## Introduction

通过输入来对以前的工作进行分类：原始视频（像素级） 或视频特征（特征级） 。

预训练的模型是特征级的，因为他们在一些大规模视频文本数据集上进行过预训练，例如 Howto100M。输入是通过现成的冻结视频特征提取器生成的缓存视频特征。如果输入是原始视频，则会使预训练非常缓慢。

像素级方法直接以原始视频作为输入来训练模型，这种方法结合成对文本学习视频特征提取器。相反，特征级方法高度依赖于合适的特征提取器：它不能将学习的梯度传播回固定的视频编码器。

最近的一些工作开始用像素级的方法对模型进行预训练，使预训练模型从原始视频中学习。最大的挑战是如何减少密集视频输入的高计算过载。本文的目标不是预训练一种新的视频文本检索模型，而是主要研究如何将知识从图片文本预训练模型 CLIP 中迁移到视频本文检索任务中 。

在本文中，作者利用预训练好的 CLIP，提出了一个名为 CLIP4Clip （CLIP for video Clip retrieval）的模型来解决视频文本检索问题。具体而言，CLIP4Clip 构建在 CLIP 之上，并设计了三种相似度计算方法：无参数型、顺序型和紧密型。与目前基于 CLIP 的工作相比，不同之处在于，他们的工作直接利用片段进行 zero-shot 预测，而没有考虑不同的相似性计算机制。然而，本文设计了一些相似性计算方法来提高性能，并以端到端的方式训练模型。

此外，通过大量的实验，作者得出了以下结论：

1）单个图像远远不足以用于视频文本检索的视频编码。

2） 在 CLIP4Clip 模型上对大规模视频文本数据集进行后预训练是必需的，并且可以提高性能，特别是对于大幅度的零样本预测。

3） 基于强大的预训练CLIP，对于小数据集，最好不要引入新参数，对视频帧采用平均池化机制；对于大数据集，最好引入更多参数，以学习大型数据集的时间依赖性。

4）视频文本检索中使用的CLIP是学习率敏感的。

## Framework

给定一组视频 $\mathcal{V}$（或视频片段）和一组文本 $\mathcal{T}$，模型的目标是学习函数 $s(v_i,t_j)$ 来计算视频（或视频片段）$v_i\in\mathcal{V}$ 与文本 $t_j\in\mathcal{T}$ 之间的相似度。根据文本到视频检索中的相似性得分对给定查询本文的所有视频（或视频片段）进行排序，或者在视频到文本检索任务中对给定查询视频（或视频片段）的所有文本进行排序。$s(v_i,t_j)$ 的目标是计算相关视频文本对的高相似度分数和不相关视频文本对的低相似度分数。
<img src="../../assets/Framework7.jpg" width="90%">

<img src="../../assets/Framework_Similarity.jpg" width="90%">

CLIP4Clip 的框架包括三个组件，包括两个单模态编码器和一个相似性计算器。该模型采用视频-文本对作为输入。对于输入视频，我们首先将输入视频采样为有序的帧（图像）。接下来，这些图像帧被重新整形为一系列展平的 2D 块。这些补丁被映射到具有线性补丁嵌入层的 1D 嵌入序列，并被输入到图像编码器以如在 ViT 中表示。最后，相似度计算器预测这些帧的文本表示和表示序列之间的相似度得分。在这项工作中，我们研究了三种类型的相似性计算器，包括无参数、顺序和紧类型表示余弦相似性。我们用 CLIP（ViT-B/32）对两个单模编码器进行了初始化。

其中，视频（或视频片段）$v_i\in\mathcal{V}$ 在本文中表示为一系列帧（图像）的集合，由 $|v_i|$ 个采样帧组成，使得 $v_i=\{v_i^1,v_i^2,\cdots,v_i^{|v_i|}\}$。本文的模型是一种端到端方式（E2E），通过将帧作为输入直接对像素进行训练。上图展示了本文的框架，它主要包含一个文本编码器 、一个视频编码器和一个相似性计算模块。

### Video Encoder

为了获得视频表示，首先从视频片段中提取帧，然后通过视频编码器对其进行编码，以获得一系列特征。在本文中，作者采用 ViT-B/32 作为视频编码器，具有 12 层，patch 大小为 32。具体地，作者使用预训练的 CLIP（VIT-B／32）作为主干网络，并且主要考虑将图像表示转移到视频表示。

ViT 首先提取非重叠图像块，然后用线性投影转换为一维的 token，并利用 Transformer 架构对输入图像的每个 patch 之间的交互进行建模，以获得最终的表示。在 CLIP 的 ViT 之后，作者使用 \[class\] token 的输出作为图像表示。对于视频的输入帧序列 $v_i=\{v_i^1,v_i^2,\cdots,v_i^{|v_i|}\}$，生成的特征可以表示为 $\mathbf{Z}_i=\{\mathbf{z}_i^1,\mathbf{z}_i^2,\cdots,\mathbf{z}_i^{|v_i|}\}$。
<img src="../../assets/linear_2d.jpg" width="90%">

<img src="../../assets/linear_3d.jpg" width="90%">


在上图中，作者展示了 Patch 线性投影模块中研究了两种类型的线性投影，分别命名为 2D 线性和 3D 线性。（a）将 ViT 的 Patch 的线性投影视为二维线性投影，独立嵌入每个二维帧patch。这样的二维线性模型忽略了帧之间的时间信息。（b）因此，作者研究了的 3D 线性投影，以增强时间特征提取。三维线性投影会跨时间的 patch。具体地说，三维线性使用以 $[t\times h\times w]$ 的核作为线性的三维卷积代替二维线性中 $[h\times w]$ 的核，其中 t、h 和 w 分别为时间、高度和宽度。

### Text Encoder

作者直接从 CLIP 中的文本编码器来生成文本表示，其文本编码器是一种 Transformer 结构。这是一个 12 层，通道为 512 的模型，有 8 个注意力头。在 CLIP 之后，\[EOS\] token 处 Transformer 最高层的激活被视为文本的特征表示。对于文本 $t_j\in\mathcal{T}$，其特征表示为 $\mathbf{w}_j$。

### Similarity Calculator
<img src="../../assets/Framework_Similarity.jpg" width="90%">


在提取视频表示 $\mathbf{Z}_i=\{\mathbf{z}_i^1,\mathbf{z}_i^2,\cdots,\mathbf{z}_i^{|v_i|}\}$ 和文本表示 $\mathbf{w}_j$ 之后，关键步骤是相似度计算。由于本文的模型是基于预训练的图像-文本模型构建的，因此应该在相似度计算模块中小心地添加新的可学习权重。如果没有权重初始化，很难进行学习，并且可能会影响使用反向传播的预训练模型训练的性能。因此，作者根据模块是否引入新参数进行学习，将相似度计算器的机制分为三类。无参数方法，即平均池化，在没有新参数的情况下融合视频表示。另外，作者还提出两种方法引入了新的权值来学习，包括具有不同大小的新权值的序列型方法和紧密型方法 。上图说明了三种机制的详细结构。无参数类型和序列类型的相似度计算器属于松散类型，采用两个单独的分支分别用于视频和文本表示来计算余弦相似度。而紧密型相似性计算器使用 Transformer 模型进行多模态交互，并通过线性投影进一步计算相似性，两者都包含新的权重以供学习。

#### Parameter-free type

通过对图像-文本对的大规模预训练的CLIP，帧表示 $\mathbf{Z}_i=\{\mathbf{z}_i^1,\mathbf{z}_i^2,\cdots,\mathbf{z}_i^{|v_i|}\}$ 和文本表示 $\mathbf{w}_j$ 已被层归一化并线性投影到多模态嵌入空间。因此，一个自然的想法是采用无参数类型直接从视频角度计算与图像/帧的相似性。无参数类型首先使用平均池化来聚合所有帧的特征，以获得“平均帧” $\hat{\mathbf{z}}_i=\text{mean-pooling}(\mathbf{z}_i^1,\mathbf{z}_i^2,\cdots,\mathbf{z}_i^{|v_i|})$，然后，将相似性函数 $s(v_i,t_j)$ 定义为余弦相似度：

$$s(v_i,t_j)=\dfrac{\mathbf{w}_j^\top\hat{\mathbf{z}}_i}{||\mathbf{w}_j||||\hat{\mathbf{z}}_i||}$$

#### Sequential type

平均池化操作忽略帧之间的顺序信息。因此，作者探索了两种为序列类型相似性计算器建模序列特征的方法。一个是 LSTM，另一个是带位置嵌入的 Transformer 编码器。这两种模型都是序列特征的有效模型。作者将它们分别表示为 $\widetilde{\mathbf{Z}}_i=\text{LSTM}(\mathbf{Z}_i)$ 和 $\widetilde{\mathbf{Z}}_i=\text{Transformer-Enc}(\mathbf{Z}_i+\mathbf{P})$。通过编码，$\widetilde{\mathbf{Z}}_i$ 嵌入了时间信息。后续操作与无参数类型相似性计算器相同。

#### Tight type

与上述无参数类型和顺序类型不同，紧密型使用Transformer编码器进行视频和本文之间的多模态交互，并通过线性层预测相似性，这引入了未初始化的权重。首先，将文本表示 $\mathbf{w}_j$ 和帧表示 $\mathbf{Z}_i=\{\mathbf{z}_i^1,\mathbf{z}_i^2,\cdots,\mathbf{z}_i^{|v_i|}\}$ concat 起来作为融合特征 $\mathbf{U}_i$，然后用 Transformer 编码器进行建模，其公式如下：

$$\mathbf{U}_i=[\mathbf{w}_j,\mathbf{z}_i^1,\mathbf{z}_i^2,\cdots,\mathbf{z}_i^{|v_i|}]$$

$$\widetilde{\mathbf{U}}_i=\text{Transformer-Enc}(\mathbf{U}_i+\mathbf{P}+\mathbf{T})$$

其中，\[，\] 表示 concat 操作。$\mathbf{P}$ 是位置嵌入，$\mathbf{T}$ 是类型嵌入。它包含两种类型的嵌入，一种用于文本，另一种用于视频帧。接下来，作者使用两个线性投影层和一个激活函数来得到 $\widetilde{\mathbf{U}}_i[0,:]$ 来计算相似度，表示为 $s(v_i,t_j)=\text{FC}(\text{RELU}(\text{FC}(\widetilde{\mathbf{U}}_i[0,:])))$ ，其中 FC 是线性投影，ReLU 为激活函数。

### Training Strategy

#### Loss Function

给定一个 Batch。即 B 个视频- 文本或视频片段-文本对，模型需要生成并优化 B×B 相似度矩阵。作者使用这些相似度分数上的对称交叉熵损失来训练模型的参数：

$$\mathcal{L}_{v2t} = -\frac{1}{B} \sum_i^B{\log \frac{\exp(s(v_i, t_i))}{\sum_{j=1}^B{\exp(s(v_i, t_j))}}}$$

$$\mathcal{L}_{t2v} = -\frac{1}{B} \sum_i^B{\log \frac{\exp(s(v_i, t_i))}{\sum_{j=1}^B{\exp(s(v_j, t_i))}}}$$

$$\mathcal{L} = \mathcal{L}_{v2t} + \mathcal{L}_{t2v}$$

#### Frame Sampling

由于本文的模型是通过帧作为输入直接在像素上进行训练的，因此提取帧是一种重要的策略。一个有效的采样策略需要考虑信息丰富度和计算复杂性之间的平衡。为了考虑视频（或视频片段）中的顺序信息，作者采用了均匀的帧采样策略，而不是随机稀疏采样策略。采样率为每秒 1 帧。此外，作者还研究了不同的帧长和不同的提取位置。

#### Pre-training

虽然 CLIP 对于学习图像的视觉概念是有效的，但从视频中学习时间特征是必不可少的。为了进一步将CLIP的知识迁移为视频，作者用 CLIP4Clip 模型在 Howto100M 数据集上进行了后预训练。基于效率考虑，对视频文本数据集进行预训练是非常具有挑战性的。因此，作者使用“食品和娱乐”类别（约 380k 个视频）作为后预训练数据集（本文其余部分称为 HOWT100M-380k）。

## Experiments

Datasets: MSR-VTT、MSVC、LSMDC、ActivityNet 和 DiDeMo。